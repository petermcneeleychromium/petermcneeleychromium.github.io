<!DOCTYPE html>
<html>
<head>
    <title>GPU Side-Channel Messenger</title>
</head>
<body>

    <h1>GPU Side-Channel Messenger (Final Version)</h1>
    <p>This version uses multi-step calibration and statistical sampling to send text between tabs.</p>
    <p><b>Instructions:</b> 1. Calibrate Sender in Tab A. 2. Calibrate Listener in Tab B. 3. Start Listening in Tab B. 4. Send message from Tab A.</p>
    
    <hr>

    <h2>Control Panel</h2>
    <div>
        <button id="calibrateSenderButton">1. Calibrate Sender</button>
        <button id="calibrateListenerButton">2. Calibrate Listener</button>
        <p id="calibrationStatus" style="font-family: monospace;"></p>
    </div>

    <hr>
    
    <div style="display: flex; gap: 2em;">
        <div style="flex: 1;">
            <h2>Send Data</h2>
            <textarea id="sendText" rows="4" cols="50">ok</textarea><br>
            <button id="sendButton" disabled>4. Send</button>
            <p id="senderStatus" style="font-family: monospace;"></p>
        </div>
        <div style="flex: 1;">
            <h2>Receive Data</h2>
            <button id="listenButton" disabled>3. Start Listening</button>
            <textarea id="receiveText" readonly rows="4" cols="50"></textarea>
            <p id="listenerStatus" style="font-family: monospace;"></p>
        </div>
    </div>

    <script>
        // --- Elements ---
        const calibrateSenderButton = document.getElementById('calibrateSenderButton');
        const calibrateListenerButton = document.getElementById('calibrateListenerButton');
        const calibrationStatus = document.getElementById('calibrationStatus');
        const sendButton = document.getElementById('sendButton');
        const listenButton = document.getElementById('listenButton');
        const sendText = document.getElementById('sendText');
        const receiveText = document.getElementById('receiveText');
        const senderStatus = document.getElementById('senderStatus');
        const listenerStatus = document.getElementById('listenerStatus');

        // --- Configuration ---
        const BIT_WINDOW_MS = 6000;         // How long we send/listen for a single bit.
        const PROBE_INTERVAL_MS = 200;      // How often the listener probes within the window.
        const PROBE_ITERATION_COUNT = 50000;
        const CALIBRATION_TARGET_MS = 1000;
        const PREAMBLE = '10101010';

        // --- Global State ---
        let device;
        let calibratedIterationCount = 0;
        let calibratedProbeThreshold = 0;

        // The busy hash job function (same as previous version)
        async function runBusyHashJob(iterationCount) {
            if (!device) return 0;
            const outputBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });
            const readBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
            const uniformBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([iterationCount]));
            const seedBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            device.queue.writeBuffer(seedBuffer, 0, new Uint32Array([Math.floor(Math.random() * 0xFFFFFFFF)]));
            const shaderModule = device.createShaderModule({ code: `struct P{i:u32};@group(0)@binding(0)var<uniform>p:P;@group(0)@binding(1)var<storage,read>s:u32;@group(0)@binding(2)var<storage,read_write>r:u32;fn h(n:u32)->u32{var x=n;x=((x>>16u)^x)*0x45d9f3bu;x=((x>>16u)^x)*0x45d9f3bu;x=(x>>16u)^x;return x;}@compute @workgroup_size(1)fn main(){var t=s;for(var i=0u;i<p.i;i=i+1u){t=h(t+i);}r=t;}`});
            const pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: shaderModule, entryPoint: 'main' } });
            const bindGroup = device.createBindGroup({ layout: pipeline.getBindGroupLayout(0), entries: [{binding:0,resource:{buffer:uniformBuffer}},{binding:1,resource:{buffer:seedBuffer}},{binding:2,resource:{buffer:outputBuffer}}]});
            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.dispatchWorkgroups(1);
            passEncoder.end();
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, 4);
            const startTime = performance.now();
            device.queue.submit([commandEncoder.finish()]);
            await readBuffer.mapAsync(GPUMapMode.READ);
            const endTime = performance.now();
            readBuffer.unmap();
            outputBuffer.destroy();
            uniformBuffer.destroy();
            seedBuffer.destroy();
            readBuffer.destroy();
            return endTime - startTime;
        }
        
        // --- CALIBRATION ---
        async function calibrateSender() {
            calibrateListenerButton.disabled = true;
            calibrateSenderButton.disabled = true;
            const iterationCounts = [5e8, 1e9, 2e9, 4e9, 8e9];
            for (const count of iterationCounts) {
                calibrationStatus.textContent = `SENDER: Testing loop with ${(count / 1e9).toFixed(1)}B iterations...`;
                const duration = await runBusyHashJob(count);
                calibrationStatus.textContent = `SENDER: ... ${(count / 1e9).toFixed(1)}B iterations took ${duration.toFixed(0)} ms.`;
                if (duration > CALIBRATION_TARGET_MS) {
                    calibratedIterationCount = count;
                    calibrationStatus.textContent = `✅ Sender Calibrated! Using ${count.toLocaleString()} iterations.`;
                    sendButton.disabled = false;
                    calibrateListenerButton.disabled = false;
                    return;
                }
            }
            calibrationStatus.textContent = "❌ Sender Calibration Failed: No workload was heavy enough.";
            calibrateListenerButton.disabled = false;
        }
        
        async function calibrateListener() {
            calibrateListenerButton.disabled = true;
            calibrateSenderButton.disabled = true;
            let totalTime = 0;
            const sampleCount = 50;
            calibrationStatus.textContent = `LISTENER: Measuring baseline noise (${sampleCount} samples)...`;
            let samples = [];
            for (let i = 0; i < sampleCount; i++) {
                const duration = await runBusyHashJob(PROBE_ITERATION_COUNT);
                samples.push(duration);
            }
            samples.sort((a, b) => a - b);
            const percentile_95 = samples[Math.floor(sampleCount * 0.95)];
            calibratedProbeThreshold = percentile_95 * 2.5; // Set threshold to 2.5x the 95th percentile noise
            calibrationStatus.textContent = `✅ Listener Calibrated! Noise threshold set to ${calibratedProbeThreshold.toFixed(2)} ms.`;
            listenButton.disabled = false;
            calibrateSenderButton.disabled = false;
        }

        // --- COMMUNICATION ---
        async function sendData() {
            sendButton.disabled = true;
            const binaryString = PREAMBLE + sendText.value.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
            
            for (let i = 0; i < binaryString.length; i++) {
                const bit = binaryString[i];
                senderStatus.textContent = `Sending bit ${i + 1}/${binaryString.length}: ${bit}`;
                if (bit === '1') {
                    // For a '1', keep the GPU busy for the whole window.
                    const end = performance.now() + BIT_WINDOW_MS;
                    while (performance.now() < end) {
                        await runBusyHashJob(calibratedIterationCount);
                    }
                } else {
                    // For a '0', just sleep.
                    await new Promise(resolve => setTimeout(resolve, BIT_WINDOW_MS));
                }
            }
            senderStatus.textContent = 'Sending complete.';
            sendButton.disabled = false;
        }
        
        function listenForData() {
            listenButton.disabled = true;
            let bitBuffer = '';
            let samples = [];
            let sampleInterval;
            
            function decodeBit() {
                // Analyze the collected samples
                const busySampleCount = samples.filter(t => t > calibratedProbeThreshold).length;
                const busyPercentage = (busySampleCount / samples.length) * 100;
                const detectedBit = busyPercentage > 20 ? '1' : '0'; // If >20% of samples were busy, it's a '1'
                
                listenerStatus.textContent = `Decoded '${detectedBit}' (${busySampleCount}/${samples.length} busy samples).`;
                bitBuffer += detectedBit;

                if (bitBuffer.endsWith(PREAMBLE)) {
                     receiveText.value += "[SYNCED] ";
                     bitBuffer = '';
                }

                if (bitBuffer.length >= 8) {
                    const byte = bitBuffer.slice(0, 8);
                    receiveText.value += String.fromCharCode(parseInt(byte, 2));
                    bitBuffer = bitBuffer.slice(8);
                }

                samples = []; // Reset for next bit
            }

            // Start the sampler
            sampleInterval = setInterval(() => {
                runBusyHashJob(PROBE_ITERATION_COUNT).then(duration => samples.push(duration));
            }, PROBE_INTERVAL_MS);

            // Set up the decoder to run at the end of each bit window
            setInterval(decodeBit, BIT_WINDOW_MS);
            
            listenerStatus.textContent = `Listening... Each bit takes ${BIT_WINDOW_MS/1000} seconds.`;
        }

        // --- INITIALIZATION ---
        async function main() {
            if (await initGpu()) {
                calibrateSenderButton.onclick = calibrateSender;
                calibrateListenerButton.onclick = calibrateListener;
                sendButton.onclick = sendData;
                listenButton.onclick = listenForData;
            } else {
                calibrationStatus.textContent = "❌ WebGPU initialization failed. Cannot proceed.";
            }
        }
        main();
    </script>
</body>
</html>
